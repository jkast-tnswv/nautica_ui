// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none"
// @generated from file ledger/api/ledger.proto (package ledger, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum ledger.LedgerDnsRecordTypes
 */
export enum LedgerDnsRecordTypes {
  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_UNSPECIFIED = 0;
   */
  LEDGER_DNS_RECORD_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_A = 1;
   */
  LEDGER_DNS_RECORD_TYPE_A = 1,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_NS = 2;
   */
  LEDGER_DNS_RECORD_TYPE_NS = 2,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CNAME = 5;
   */
  LEDGER_DNS_RECORD_TYPE_CNAME = 5,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SOA = 6;
   */
  LEDGER_DNS_RECORD_TYPE_SOA = 6,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_PTR = 12;
   */
  LEDGER_DNS_RECORD_TYPE_PTR = 12,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_HINFO = 13;
   */
  LEDGER_DNS_RECORD_TYPE_HINFO = 13,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_MX = 15;
   */
  LEDGER_DNS_RECORD_TYPE_MX = 15,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_TXT = 16;
   */
  LEDGER_DNS_RECORD_TYPE_TXT = 16,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_RP = 17;
   */
  LEDGER_DNS_RECORD_TYPE_RP = 17,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_AFSDB = 18;
   */
  LEDGER_DNS_RECORD_TYPE_AFSDB = 18,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SIG = 24;
   */
  LEDGER_DNS_RECORD_TYPE_SIG = 24,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_KEY = 25;
   */
  LEDGER_DNS_RECORD_TYPE_KEY = 25,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_AAAA = 28;
   */
  LEDGER_DNS_RECORD_TYPE_AAAA = 28,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_LOC = 29;
   */
  LEDGER_DNS_RECORD_TYPE_LOC = 29,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SRV = 33;
   */
  LEDGER_DNS_RECORD_TYPE_SRV = 33,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_NAPTR = 35;
   */
  LEDGER_DNS_RECORD_TYPE_NAPTR = 35,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_KX = 36;
   */
  LEDGER_DNS_RECORD_TYPE_KX = 36,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CERT = 37;
   */
  LEDGER_DNS_RECORD_TYPE_CERT = 37,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_DNAME = 39;
   */
  LEDGER_DNS_RECORD_TYPE_DNAME = 39,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_OPT = 41;
   */
  LEDGER_DNS_RECORD_TYPE_OPT = 41,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_APL = 42;
   */
  LEDGER_DNS_RECORD_TYPE_APL = 42,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_DS = 43;
   */
  LEDGER_DNS_RECORD_TYPE_DS = 43,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SSHFP = 44;
   */
  LEDGER_DNS_RECORD_TYPE_SSHFP = 44,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_IPSECKEY = 45;
   */
  LEDGER_DNS_RECORD_TYPE_IPSECKEY = 45,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_RRSIG = 46;
   */
  LEDGER_DNS_RECORD_TYPE_RRSIG = 46,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_NSEC = 47;
   */
  LEDGER_DNS_RECORD_TYPE_NSEC = 47,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_DNSKEY = 48;
   */
  LEDGER_DNS_RECORD_TYPE_DNSKEY = 48,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_DHCID = 49;
   */
  LEDGER_DNS_RECORD_TYPE_DHCID = 49,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_NSEC3 = 50;
   */
  LEDGER_DNS_RECORD_TYPE_NSEC3 = 50,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_NSEC3PARAM = 51;
   */
  LEDGER_DNS_RECORD_TYPE_NSEC3PARAM = 51,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_TLSA = 52;
   */
  LEDGER_DNS_RECORD_TYPE_TLSA = 52,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SMIMEA = 53;
   */
  LEDGER_DNS_RECORD_TYPE_SMIMEA = 53,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_HIP = 55;
   */
  LEDGER_DNS_RECORD_TYPE_HIP = 55,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CDS = 59;
   */
  LEDGER_DNS_RECORD_TYPE_CDS = 59,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CDNSKEY = 60;
   */
  LEDGER_DNS_RECORD_TYPE_CDNSKEY = 60,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_OPENPGPKEY = 61;
   */
  LEDGER_DNS_RECORD_TYPE_OPENPGPKEY = 61,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CSYNC = 62;
   */
  LEDGER_DNS_RECORD_TYPE_CSYNC = 62,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_ZONEMD = 63;
   */
  LEDGER_DNS_RECORD_TYPE_ZONEMD = 63,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_SVCB = 64;
   */
  LEDGER_DNS_RECORD_TYPE_SVCB = 64,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_HTTPS = 65;
   */
  LEDGER_DNS_RECORD_TYPE_HTTPS = 65,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_EUI48 = 108;
   */
  LEDGER_DNS_RECORD_TYPE_EUI48 = 108,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_EUI64 = 109;
   */
  LEDGER_DNS_RECORD_TYPE_EUI64 = 109,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_TKEY = 249;
   */
  LEDGER_DNS_RECORD_TYPE_TKEY = 249,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_TSIG = 250;
   */
  LEDGER_DNS_RECORD_TYPE_TSIG = 250,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_IXFR = 251;
   */
  LEDGER_DNS_RECORD_TYPE_IXFR = 251,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_AXFR = 252;
   */
  LEDGER_DNS_RECORD_TYPE_AXFR = 252,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_URI = 256;
   */
  LEDGER_DNS_RECORD_TYPE_URI = 256,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_CAA = 257;
   */
  LEDGER_DNS_RECORD_TYPE_CAA = 257,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_TA = 32768;
   */
  LEDGER_DNS_RECORD_TYPE_TA = 32768,

  /**
   * @generated from enum value: LEDGER_DNS_RECORD_TYPE_DLV = 32769;
   */
  LEDGER_DNS_RECORD_TYPE_DLV = 32769,
}
// Retrieve enum metadata with: proto3.getEnumType(LedgerDnsRecordTypes)
proto3.util.setEnumType(LedgerDnsRecordTypes, "ledger.LedgerDnsRecordTypes", [
  { no: 0, name: "LEDGER_DNS_RECORD_TYPE_UNSPECIFIED" },
  { no: 1, name: "LEDGER_DNS_RECORD_TYPE_A" },
  { no: 2, name: "LEDGER_DNS_RECORD_TYPE_NS" },
  { no: 5, name: "LEDGER_DNS_RECORD_TYPE_CNAME" },
  { no: 6, name: "LEDGER_DNS_RECORD_TYPE_SOA" },
  { no: 12, name: "LEDGER_DNS_RECORD_TYPE_PTR" },
  { no: 13, name: "LEDGER_DNS_RECORD_TYPE_HINFO" },
  { no: 15, name: "LEDGER_DNS_RECORD_TYPE_MX" },
  { no: 16, name: "LEDGER_DNS_RECORD_TYPE_TXT" },
  { no: 17, name: "LEDGER_DNS_RECORD_TYPE_RP" },
  { no: 18, name: "LEDGER_DNS_RECORD_TYPE_AFSDB" },
  { no: 24, name: "LEDGER_DNS_RECORD_TYPE_SIG" },
  { no: 25, name: "LEDGER_DNS_RECORD_TYPE_KEY" },
  { no: 28, name: "LEDGER_DNS_RECORD_TYPE_AAAA" },
  { no: 29, name: "LEDGER_DNS_RECORD_TYPE_LOC" },
  { no: 33, name: "LEDGER_DNS_RECORD_TYPE_SRV" },
  { no: 35, name: "LEDGER_DNS_RECORD_TYPE_NAPTR" },
  { no: 36, name: "LEDGER_DNS_RECORD_TYPE_KX" },
  { no: 37, name: "LEDGER_DNS_RECORD_TYPE_CERT" },
  { no: 39, name: "LEDGER_DNS_RECORD_TYPE_DNAME" },
  { no: 41, name: "LEDGER_DNS_RECORD_TYPE_OPT" },
  { no: 42, name: "LEDGER_DNS_RECORD_TYPE_APL" },
  { no: 43, name: "LEDGER_DNS_RECORD_TYPE_DS" },
  { no: 44, name: "LEDGER_DNS_RECORD_TYPE_SSHFP" },
  { no: 45, name: "LEDGER_DNS_RECORD_TYPE_IPSECKEY" },
  { no: 46, name: "LEDGER_DNS_RECORD_TYPE_RRSIG" },
  { no: 47, name: "LEDGER_DNS_RECORD_TYPE_NSEC" },
  { no: 48, name: "LEDGER_DNS_RECORD_TYPE_DNSKEY" },
  { no: 49, name: "LEDGER_DNS_RECORD_TYPE_DHCID" },
  { no: 50, name: "LEDGER_DNS_RECORD_TYPE_NSEC3" },
  { no: 51, name: "LEDGER_DNS_RECORD_TYPE_NSEC3PARAM" },
  { no: 52, name: "LEDGER_DNS_RECORD_TYPE_TLSA" },
  { no: 53, name: "LEDGER_DNS_RECORD_TYPE_SMIMEA" },
  { no: 55, name: "LEDGER_DNS_RECORD_TYPE_HIP" },
  { no: 59, name: "LEDGER_DNS_RECORD_TYPE_CDS" },
  { no: 60, name: "LEDGER_DNS_RECORD_TYPE_CDNSKEY" },
  { no: 61, name: "LEDGER_DNS_RECORD_TYPE_OPENPGPKEY" },
  { no: 62, name: "LEDGER_DNS_RECORD_TYPE_CSYNC" },
  { no: 63, name: "LEDGER_DNS_RECORD_TYPE_ZONEMD" },
  { no: 64, name: "LEDGER_DNS_RECORD_TYPE_SVCB" },
  { no: 65, name: "LEDGER_DNS_RECORD_TYPE_HTTPS" },
  { no: 108, name: "LEDGER_DNS_RECORD_TYPE_EUI48" },
  { no: 109, name: "LEDGER_DNS_RECORD_TYPE_EUI64" },
  { no: 249, name: "LEDGER_DNS_RECORD_TYPE_TKEY" },
  { no: 250, name: "LEDGER_DNS_RECORD_TYPE_TSIG" },
  { no: 251, name: "LEDGER_DNS_RECORD_TYPE_IXFR" },
  { no: 252, name: "LEDGER_DNS_RECORD_TYPE_AXFR" },
  { no: 256, name: "LEDGER_DNS_RECORD_TYPE_URI" },
  { no: 257, name: "LEDGER_DNS_RECORD_TYPE_CAA" },
  { no: 32768, name: "LEDGER_DNS_RECORD_TYPE_TA" },
  { no: 32769, name: "LEDGER_DNS_RECORD_TYPE_DLV" },
]);

/**
 * @generated from message ledger.LedgerIpv4AddressString
 */
export class LedgerIpv4AddressString extends Message<LedgerIpv4AddressString> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<LedgerIpv4AddressString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv4AddressString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv4AddressString {
    return new LedgerIpv4AddressString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv4AddressString {
    return new LedgerIpv4AddressString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv4AddressString {
    return new LedgerIpv4AddressString().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv4AddressString | PlainMessage<LedgerIpv4AddressString> | undefined, b: LedgerIpv4AddressString | PlainMessage<LedgerIpv4AddressString> | undefined): boolean {
    return proto3.util.equals(LedgerIpv4AddressString, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv4AddressBytes
 */
export class LedgerIpv4AddressBytes extends Message<LedgerIpv4AddressBytes> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  constructor(data?: PartialMessage<LedgerIpv4AddressBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv4AddressBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv4AddressBytes {
    return new LedgerIpv4AddressBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv4AddressBytes {
    return new LedgerIpv4AddressBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv4AddressBytes {
    return new LedgerIpv4AddressBytes().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv4AddressBytes | PlainMessage<LedgerIpv4AddressBytes> | undefined, b: LedgerIpv4AddressBytes | PlainMessage<LedgerIpv4AddressBytes> | undefined): boolean {
    return proto3.util.equals(LedgerIpv4AddressBytes, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv4AddressOctets
 */
export class LedgerIpv4AddressOctets extends Message<LedgerIpv4AddressOctets> {
  /**
   * @generated from field: uint32 octet1 = 1;
   */
  octet1 = 0;

  /**
   * @generated from field: uint32 octet2 = 2;
   */
  octet2 = 0;

  /**
   * @generated from field: uint32 octet3 = 3;
   */
  octet3 = 0;

  /**
   * @generated from field: uint32 octet4 = 4;
   */
  octet4 = 0;

  constructor(data?: PartialMessage<LedgerIpv4AddressOctets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv4AddressOctets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "octet1", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "octet2", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "octet3", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "octet4", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv4AddressOctets {
    return new LedgerIpv4AddressOctets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv4AddressOctets {
    return new LedgerIpv4AddressOctets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv4AddressOctets {
    return new LedgerIpv4AddressOctets().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv4AddressOctets | PlainMessage<LedgerIpv4AddressOctets> | undefined, b: LedgerIpv4AddressOctets | PlainMessage<LedgerIpv4AddressOctets> | undefined): boolean {
    return proto3.util.equals(LedgerIpv4AddressOctets, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv4Address
 */
export class LedgerIpv4Address extends Message<LedgerIpv4Address> {
  /**
   * @generated from oneof ledger.LedgerIpv4Address.ipv4_address
   */
  ipv4Address: {
    /**
     * @generated from field: ledger.LedgerIpv4AddressString ipv4_address_string = 1;
     */
    value: LedgerIpv4AddressString;
    case: "ipv4AddressString";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv4AddressBytes ipv4_address_bytes = 2;
     */
    value: LedgerIpv4AddressBytes;
    case: "ipv4AddressBytes";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv4AddressOctets ipv4_address_octets = 3;
     */
    value: LedgerIpv4AddressOctets;
    case: "ipv4AddressOctets";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LedgerIpv4Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv4Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ipv4_address_string", kind: "message", T: LedgerIpv4AddressString, oneof: "ipv4_address" },
    { no: 2, name: "ipv4_address_bytes", kind: "message", T: LedgerIpv4AddressBytes, oneof: "ipv4_address" },
    { no: 3, name: "ipv4_address_octets", kind: "message", T: LedgerIpv4AddressOctets, oneof: "ipv4_address" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv4Address {
    return new LedgerIpv4Address().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv4Address {
    return new LedgerIpv4Address().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv4Address {
    return new LedgerIpv4Address().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv4Address | PlainMessage<LedgerIpv4Address> | undefined, b: LedgerIpv4Address | PlainMessage<LedgerIpv4Address> | undefined): boolean {
    return proto3.util.equals(LedgerIpv4Address, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv6AddressString
 */
export class LedgerIpv6AddressString extends Message<LedgerIpv6AddressString> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<LedgerIpv6AddressString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv6AddressString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv6AddressString {
    return new LedgerIpv6AddressString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv6AddressString {
    return new LedgerIpv6AddressString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv6AddressString {
    return new LedgerIpv6AddressString().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv6AddressString | PlainMessage<LedgerIpv6AddressString> | undefined, b: LedgerIpv6AddressString | PlainMessage<LedgerIpv6AddressString> | undefined): boolean {
    return proto3.util.equals(LedgerIpv6AddressString, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv6AddressBytes
 */
export class LedgerIpv6AddressBytes extends Message<LedgerIpv6AddressBytes> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  constructor(data?: PartialMessage<LedgerIpv6AddressBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv6AddressBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv6AddressBytes {
    return new LedgerIpv6AddressBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv6AddressBytes {
    return new LedgerIpv6AddressBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv6AddressBytes {
    return new LedgerIpv6AddressBytes().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv6AddressBytes | PlainMessage<LedgerIpv6AddressBytes> | undefined, b: LedgerIpv6AddressBytes | PlainMessage<LedgerIpv6AddressBytes> | undefined): boolean {
    return proto3.util.equals(LedgerIpv6AddressBytes, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv6AddressHextets
 */
export class LedgerIpv6AddressHextets extends Message<LedgerIpv6AddressHextets> {
  /**
   * @generated from field: string hextet1 = 1;
   */
  hextet1 = "";

  /**
   * @generated from field: string hextet2 = 2;
   */
  hextet2 = "";

  /**
   * @generated from field: string hextet3 = 3;
   */
  hextet3 = "";

  /**
   * @generated from field: string hextet4 = 4;
   */
  hextet4 = "";

  /**
   * @generated from field: string hextet5 = 5;
   */
  hextet5 = "";

  /**
   * @generated from field: string hextet6 = 6;
   */
  hextet6 = "";

  /**
   * @generated from field: string hextet7 = 7;
   */
  hextet7 = "";

  /**
   * @generated from field: string hextet8 = 8;
   */
  hextet8 = "";

  constructor(data?: PartialMessage<LedgerIpv6AddressHextets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv6AddressHextets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hextet1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hextet2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hextet3", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "hextet4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "hextet5", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "hextet6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "hextet7", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "hextet8", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv6AddressHextets {
    return new LedgerIpv6AddressHextets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv6AddressHextets {
    return new LedgerIpv6AddressHextets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv6AddressHextets {
    return new LedgerIpv6AddressHextets().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv6AddressHextets | PlainMessage<LedgerIpv6AddressHextets> | undefined, b: LedgerIpv6AddressHextets | PlainMessage<LedgerIpv6AddressHextets> | undefined): boolean {
    return proto3.util.equals(LedgerIpv6AddressHextets, a, b);
  }
}

/**
 * @generated from message ledger.LedgerIpv6Address
 */
export class LedgerIpv6Address extends Message<LedgerIpv6Address> {
  /**
   * @generated from oneof ledger.LedgerIpv6Address.ipv6_address
   */
  ipv6Address: {
    /**
     * @generated from field: ledger.LedgerIpv6AddressString ipv6_address_string = 1;
     */
    value: LedgerIpv6AddressString;
    case: "ipv6AddressString";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv6AddressBytes ipv6_address_bytes = 2;
     */
    value: LedgerIpv6AddressBytes;
    case: "ipv6AddressBytes";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv6AddressHextets ipv6_address_hextets = 3;
     */
    value: LedgerIpv6AddressHextets;
    case: "ipv6AddressHextets";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LedgerIpv6Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerIpv6Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ipv6_address_string", kind: "message", T: LedgerIpv6AddressString, oneof: "ipv6_address" },
    { no: 2, name: "ipv6_address_bytes", kind: "message", T: LedgerIpv6AddressBytes, oneof: "ipv6_address" },
    { no: 3, name: "ipv6_address_hextets", kind: "message", T: LedgerIpv6AddressHextets, oneof: "ipv6_address" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerIpv6Address {
    return new LedgerIpv6Address().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerIpv6Address {
    return new LedgerIpv6Address().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerIpv6Address {
    return new LedgerIpv6Address().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerIpv6Address | PlainMessage<LedgerIpv6Address> | undefined, b: LedgerIpv6Address | PlainMessage<LedgerIpv6Address> | undefined): boolean {
    return proto3.util.equals(LedgerIpv6Address, a, b);
  }
}

/**
 * @generated from message ledger.LedgerSubnet
 */
export class LedgerSubnet extends Message<LedgerSubnet> {
  /**
   * @generated from oneof ledger.LedgerSubnet.ledger_address
   */
  ledgerAddress: {
    /**
     * @generated from field: ledger.LedgerIpv4Address ledger_ipv4_address = 1;
     */
    value: LedgerIpv4Address;
    case: "ledgerIpv4Address";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv6Address ledger_ipv6_address = 2;
     */
    value: LedgerIpv6Address;
    case: "ledgerIpv6Address";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: uint32 prefix_length = 3;
   */
  prefixLength = 0;

  constructor(data?: PartialMessage<LedgerSubnet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerSubnet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ledger_ipv4_address", kind: "message", T: LedgerIpv4Address, oneof: "ledger_address" },
    { no: 2, name: "ledger_ipv6_address", kind: "message", T: LedgerIpv6Address, oneof: "ledger_address" },
    { no: 3, name: "prefix_length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerSubnet {
    return new LedgerSubnet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerSubnet {
    return new LedgerSubnet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerSubnet {
    return new LedgerSubnet().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerSubnet | PlainMessage<LedgerSubnet> | undefined, b: LedgerSubnet | PlainMessage<LedgerSubnet> | undefined): boolean {
    return proto3.util.equals(LedgerSubnet, a, b);
  }
}

/**
 * @generated from message ledger.LedgerDnsRecord
 */
export class LedgerDnsRecord extends Message<LedgerDnsRecord> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: ledger.LedgerDnsRecordTypes ledger_dns_record_type = 2;
   */
  ledgerDnsRecordType = LedgerDnsRecordTypes.LEDGER_DNS_RECORD_TYPE_UNSPECIFIED;

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<LedgerDnsRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerDnsRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ledger_dns_record_type", kind: "enum", T: proto3.getEnumType(LedgerDnsRecordTypes) },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerDnsRecord {
    return new LedgerDnsRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerDnsRecord {
    return new LedgerDnsRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerDnsRecord {
    return new LedgerDnsRecord().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerDnsRecord | PlainMessage<LedgerDnsRecord> | undefined, b: LedgerDnsRecord | PlainMessage<LedgerDnsRecord> | undefined): boolean {
    return proto3.util.equals(LedgerDnsRecord, a, b);
  }
}

/**
 * @generated from message ledger.LedgerSearchRequest
 */
export class LedgerSearchRequest extends Message<LedgerSearchRequest> {
  /**
   * @generated from oneof ledger.LedgerSearchRequest.target
   */
  target: {
    /**
     * @generated from field: string name = 1;
     */
    value: string;
    case: "name";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv4Address ipv4_address = 2;
     */
    value: LedgerIpv4Address;
    case: "ipv4Address";
  } | {
    /**
     * @generated from field: ledger.LedgerIpv6Address ipv6_address = 3;
     */
    value: LedgerIpv6Address;
    case: "ipv6Address";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LedgerSearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerSearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "target" },
    { no: 2, name: "ipv4_address", kind: "message", T: LedgerIpv4Address, oneof: "target" },
    { no: 3, name: "ipv6_address", kind: "message", T: LedgerIpv6Address, oneof: "target" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerSearchRequest {
    return new LedgerSearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerSearchRequest {
    return new LedgerSearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerSearchRequest {
    return new LedgerSearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerSearchRequest | PlainMessage<LedgerSearchRequest> | undefined, b: LedgerSearchRequest | PlainMessage<LedgerSearchRequest> | undefined): boolean {
    return proto3.util.equals(LedgerSearchRequest, a, b);
  }
}

/**
 * @generated from message ledger.LedgerSearchResponse
 */
export class LedgerSearchResponse extends Message<LedgerSearchResponse> {
  /**
   * @generated from field: repeated ledger.LedgerDnsRecord ledger_dns_records = 1;
   */
  ledgerDnsRecords: LedgerDnsRecord[] = [];

  constructor(data?: PartialMessage<LedgerSearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ledger.LedgerSearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ledger_dns_records", kind: "message", T: LedgerDnsRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedgerSearchResponse {
    return new LedgerSearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedgerSearchResponse {
    return new LedgerSearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedgerSearchResponse {
    return new LedgerSearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LedgerSearchResponse | PlainMessage<LedgerSearchResponse> | undefined, b: LedgerSearchResponse | PlainMessage<LedgerSearchResponse> | undefined): boolean {
    return proto3.util.equals(LedgerSearchResponse, a, b);
  }
}

