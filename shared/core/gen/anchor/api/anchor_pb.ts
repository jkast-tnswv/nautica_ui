// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none"
// @generated from file anchor/api/anchor.proto (package anchor, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CountryCodes, StateCodes } from "./iso_3166_pb";

/**
 * @generated from enum anchor.RackModels
 */
export enum RackModels {
  /**
   * @generated from enum value: RACK_MODEL_UNSPECIFIED = 0;
   */
  RACK_MODEL_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RACK_MODEL_GENERIC = 1;
   */
  RACK_MODEL_GENERIC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RackModels)
proto3.util.setEnumType(RackModels, "anchor.RackModels", [
  { no: 0, name: "RACK_MODEL_UNSPECIFIED" },
  { no: 1, name: "RACK_MODEL_GENERIC" },
]);

/**
 * @generated from enum anchor.RackPosts
 */
export enum RackPosts {
  /**
   * @generated from enum value: RACK_POST_UNSPECIFIED = 0;
   */
  RACK_POST_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RACK_POST_GENERIC = 1;
   */
  RACK_POST_GENERIC = 1,

  /**
   * @generated from enum value: RACK_POST_2_POST = 2;
   */
  RACK_POST_2_POST = 2,

  /**
   * @generated from enum value: RACK_POST_4_POST = 3;
   */
  RACK_POST_4_POST = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RackPosts)
proto3.util.setEnumType(RackPosts, "anchor.RackPosts", [
  { no: 0, name: "RACK_POST_UNSPECIFIED" },
  { no: 1, name: "RACK_POST_GENERIC" },
  { no: 2, name: "RACK_POST_2_POST" },
  { no: 3, name: "RACK_POST_4_POST" },
]);

/**
 * @generated from enum anchor.RackWidths
 */
export enum RackWidths {
  /**
   * @generated from enum value: RACK_WIDTH_UNSPECIFIED = 0;
   */
  RACK_WIDTH_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RACK_WIDTH_GENERIC = 1;
   */
  RACK_WIDTH_GENERIC = 1,

  /**
   * @generated from enum value: RACK_WIDTH_19_INCH = 2;
   */
  RACK_WIDTH_19_INCH = 2,

  /**
   * @generated from enum value: RACK_WIDTH_21_INCH = 3;
   */
  RACK_WIDTH_21_INCH = 3,

  /**
   * @generated from enum value: RACK_WIDTH_23_INCH = 4;
   */
  RACK_WIDTH_23_INCH = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RackWidths)
proto3.util.setEnumType(RackWidths, "anchor.RackWidths", [
  { no: 0, name: "RACK_WIDTH_UNSPECIFIED" },
  { no: 1, name: "RACK_WIDTH_GENERIC" },
  { no: 2, name: "RACK_WIDTH_19_INCH" },
  { no: 3, name: "RACK_WIDTH_21_INCH" },
  { no: 4, name: "RACK_WIDTH_23_INCH" },
]);

/**
 * @generated from enum anchor.RackFaces
 */
export enum RackFaces {
  /**
   * @generated from enum value: RACK_FACE_UNSPECIFIED = 0;
   */
  RACK_FACE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RACK_FACE_GENERIC = 1;
   */
  RACK_FACE_GENERIC = 1,

  /**
   * @generated from enum value: RACK_FACE_FRONT = 2;
   */
  RACK_FACE_FRONT = 2,

  /**
   * @generated from enum value: RACK_FACE_BACK = 3;
   */
  RACK_FACE_BACK = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RackFaces)
proto3.util.setEnumType(RackFaces, "anchor.RackFaces", [
  { no: 0, name: "RACK_FACE_UNSPECIFIED" },
  { no: 1, name: "RACK_FACE_GENERIC" },
  { no: 2, name: "RACK_FACE_FRONT" },
  { no: 3, name: "RACK_FACE_BACK" },
]);

/**
 * @generated from enum anchor.BuildingCodes
 */
export enum BuildingCodes {
  /**
   * @generated from enum value: BUILDING_CODE_UNSPECIFIED = 0;
   */
  BUILDING_CODE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: BUILDING_CODE_GENERIC = 1;
   */
  BUILDING_CODE_GENERIC = 1,

  /**
   * @generated from enum value: BUILDING_CODE_MIA1 = 2;
   */
  BUILDING_CODE_MIA1 = 2,

  /**
   * @generated from enum value: BUILDING_CODE_TUS1 = 3;
   */
  BUILDING_CODE_TUS1 = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(BuildingCodes)
proto3.util.setEnumType(BuildingCodes, "anchor.BuildingCodes", [
  { no: 0, name: "BUILDING_CODE_UNSPECIFIED" },
  { no: 1, name: "BUILDING_CODE_GENERIC" },
  { no: 2, name: "BUILDING_CODE_MIA1" },
  { no: 3, name: "BUILDING_CODE_TUS1" },
]);

/**
 * @generated from enum anchor.CampusCodes
 */
export enum CampusCodes {
  /**
   * @generated from enum value: CAMPUS_CODE_UNSPECIFIED = 0;
   */
  CAMPUS_CODE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: CAMPUS_CODE_GENERIC = 1;
   */
  CAMPUS_CODE_GENERIC = 1,

  /**
   * @generated from enum value: CAMPUS_CODE_MIA = 2;
   */
  CAMPUS_CODE_MIA = 2,

  /**
   * @generated from enum value: CAMPUS_CODE_TUS = 3;
   */
  CAMPUS_CODE_TUS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CampusCodes)
proto3.util.setEnumType(CampusCodes, "anchor.CampusCodes", [
  { no: 0, name: "CAMPUS_CODE_UNSPECIFIED" },
  { no: 1, name: "CAMPUS_CODE_GENERIC" },
  { no: 2, name: "CAMPUS_CODE_MIA" },
  { no: 3, name: "CAMPUS_CODE_TUS" },
]);

/**
 * @generated from message anchor.Unit
 */
export class Unit extends Message<Unit> {
  /**
   * @generated from oneof anchor.Unit.unit_type
   */
  unitType: {
    /**
     * @generated from field: uint32 rack_unit = 1;
     */
    value: number;
    case: "rackUnit";
  } | {
    /**
     * @generated from field: uint32 open_unit = 2;
     */
    value: number;
    case: "openUnit";
  } | {
    /**
     * @generated from field: string vertical_unit = 3;
     */
    value: string;
    case: "verticalUnit";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Unit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Unit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rack_unit", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "unit_type" },
    { no: 2, name: "open_unit", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "unit_type" },
    { no: 3, name: "vertical_unit", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "unit_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Unit {
    return new Unit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Unit {
    return new Unit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Unit {
    return new Unit().fromJsonString(jsonString, options);
  }

  static equals(a: Unit | PlainMessage<Unit> | undefined, b: Unit | PlainMessage<Unit> | undefined): boolean {
    return proto3.util.equals(Unit, a, b);
  }
}

/**
 * @generated from message anchor.RackPosition
 */
export class RackPosition extends Message<RackPosition> {
  /**
   * @generated from field: anchor.Unit unit = 1;
   */
  unit?: Unit;

  /**
   * @generated from field: anchor.RackFaces rack_face = 2;
   */
  rackFace = RackFaces.RACK_FACE_UNSPECIFIED;

  constructor(data?: PartialMessage<RackPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.RackPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unit", kind: "message", T: Unit },
    { no: 2, name: "rack_face", kind: "enum", T: proto3.getEnumType(RackFaces) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RackPosition {
    return new RackPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RackPosition {
    return new RackPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RackPosition {
    return new RackPosition().fromJsonString(jsonString, options);
  }

  static equals(a: RackPosition | PlainMessage<RackPosition> | undefined, b: RackPosition | PlainMessage<RackPosition> | undefined): boolean {
    return proto3.util.equals(RackPosition, a, b);
  }
}

/**
 * @generated from message anchor.Rack
 */
export class Rack extends Message<Rack> {
  /**
   * @generated from field: anchor.RackModels rack_model = 1;
   */
  rackModel = RackModels.RACK_MODEL_UNSPECIFIED;

  /**
   * @generated from field: anchor.RackPosts rack_post = 2;
   */
  rackPost = RackPosts.RACK_POST_UNSPECIFIED;

  /**
   * @generated from field: anchor.RackWidths rack_width = 3;
   */
  rackWidth = RackWidths.RACK_WIDTH_UNSPECIFIED;

  /**
   * @generated from field: map<uint32, anchor.RackPosition> rack_position_map = 4;
   */
  rackPositionMap: { [key: number]: RackPosition } = {};

  constructor(data?: PartialMessage<Rack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Rack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rack_model", kind: "enum", T: proto3.getEnumType(RackModels) },
    { no: 2, name: "rack_post", kind: "enum", T: proto3.getEnumType(RackPosts) },
    { no: 3, name: "rack_width", kind: "enum", T: proto3.getEnumType(RackWidths) },
    { no: 4, name: "rack_position_map", kind: "map", K: 13 /* ScalarType.UINT32 */, V: {kind: "message", T: RackPosition} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rack {
    return new Rack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rack {
    return new Rack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rack {
    return new Rack().fromJsonString(jsonString, options);
  }

  static equals(a: Rack | PlainMessage<Rack> | undefined, b: Rack | PlainMessage<Rack> | undefined): boolean {
    return proto3.util.equals(Rack, a, b);
  }
}

/**
 * @generated from message anchor.PhysicalRow
 */
export class PhysicalRow extends Message<PhysicalRow> {
  /**
   *  Rack Name: Rack
   *
   * @generated from field: map<string, anchor.Rack> rack_map = 1;
   */
  rackMap: { [key: string]: Rack } = {};

  constructor(data?: PartialMessage<PhysicalRow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.PhysicalRow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rack_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Rack} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhysicalRow {
    return new PhysicalRow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhysicalRow {
    return new PhysicalRow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhysicalRow {
    return new PhysicalRow().fromJsonString(jsonString, options);
  }

  static equals(a: PhysicalRow | PlainMessage<PhysicalRow> | undefined, b: PhysicalRow | PlainMessage<PhysicalRow> | undefined): boolean {
    return proto3.util.equals(PhysicalRow, a, b);
  }
}

/**
 * @generated from message anchor.Room
 */
export class Room extends Message<Room> {
  /**
   * PhysicalRow Name: PhysicalRow
   *
   * @generated from field: map<string, anchor.PhysicalRow> physical_row_map = 1;
   */
  physicalRowMap: { [key: string]: PhysicalRow } = {};

  constructor(data?: PartialMessage<Room>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Room";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "physical_row_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PhysicalRow} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Room {
    return new Room().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Room {
    return new Room().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Room {
    return new Room().fromJsonString(jsonString, options);
  }

  static equals(a: Room | PlainMessage<Room> | undefined, b: Room | PlainMessage<Room> | undefined): boolean {
    return proto3.util.equals(Room, a, b);
  }
}

/**
 * @generated from message anchor.Floor
 */
export class Floor extends Message<Floor> {
  /**
   * Room Name: Room
   *
   * @generated from field: map<string, anchor.Room> room_map = 1;
   */
  roomMap: { [key: string]: Room } = {};

  constructor(data?: PartialMessage<Floor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Floor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "room_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Room} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Floor {
    return new Floor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Floor {
    return new Floor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Floor {
    return new Floor().fromJsonString(jsonString, options);
  }

  static equals(a: Floor | PlainMessage<Floor> | undefined, b: Floor | PlainMessage<Floor> | undefined): boolean {
    return proto3.util.equals(Floor, a, b);
  }
}

/**
 * @generated from message anchor.Building
 */
export class Building extends Message<Building> {
  /**
   * @generated from field: anchor.BuildingCodes building_code = 1;
   */
  buildingCode = BuildingCodes.BUILDING_CODE_UNSPECIFIED;

  /**
   * Floor Name: Floor
   *
   * @generated from field: map<string, anchor.Floor> floor_map = 2;
   */
  floorMap: { [key: string]: Floor } = {};

  constructor(data?: PartialMessage<Building>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Building";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "building_code", kind: "enum", T: proto3.getEnumType(BuildingCodes) },
    { no: 2, name: "floor_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Floor} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Building {
    return new Building().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Building {
    return new Building().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Building {
    return new Building().fromJsonString(jsonString, options);
  }

  static equals(a: Building | PlainMessage<Building> | undefined, b: Building | PlainMessage<Building> | undefined): boolean {
    return proto3.util.equals(Building, a, b);
  }
}

/**
 * @generated from message anchor.Campus
 */
export class Campus extends Message<Campus> {
  /**
   * @generated from field: anchor.CampusCodes campus_code = 1;
   */
  campusCode = CampusCodes.CAMPUS_CODE_UNSPECIFIED;

  /**
   * Building Name: Building
   *
   * @generated from field: map<string, anchor.Building> building_map = 2;
   */
  buildingMap: { [key: string]: Building } = {};

  constructor(data?: PartialMessage<Campus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Campus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "campus_code", kind: "enum", T: proto3.getEnumType(CampusCodes) },
    { no: 2, name: "building_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Building} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Campus {
    return new Campus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Campus {
    return new Campus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Campus {
    return new Campus().fromJsonString(jsonString, options);
  }

  static equals(a: Campus | PlainMessage<Campus> | undefined, b: Campus | PlainMessage<Campus> | undefined): boolean {
    return proto3.util.equals(Campus, a, b);
  }
}

/**
 * @generated from message anchor.State
 */
export class State extends Message<State> {
  /**
   * @generated from field: iso_3166.StateCodes state_code = 1;
   */
  stateCode = StateCodes.STATE_CODE_UNSPECIFIED;

  /**
   * Campus Name: Campus
   *
   * @generated from field: map<string, anchor.Campus> campus_map = 2;
   */
  campusMap: { [key: string]: Campus } = {};

  constructor(data?: PartialMessage<State>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.State";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_code", kind: "enum", T: proto3.getEnumType(StateCodes) },
    { no: 2, name: "campus_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Campus} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): State {
    return new State().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): State {
    return new State().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): State {
    return new State().fromJsonString(jsonString, options);
  }

  static equals(a: State | PlainMessage<State> | undefined, b: State | PlainMessage<State> | undefined): boolean {
    return proto3.util.equals(State, a, b);
  }
}

/**
 * @generated from message anchor.Country
 */
export class Country extends Message<Country> {
  /**
   * @generated from field: iso_3166.CountryCodes country_code = 1;
   */
  countryCode = CountryCodes.COUNTRY_CODE_UNSPECIFIED;

  /**
   * State/Province Name: State
   *
   * @generated from field: map<string, anchor.State> state_map = 2;
   */
  stateMap: { [key: string]: State } = {};

  constructor(data?: PartialMessage<Country>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anchor.Country";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "country_code", kind: "enum", T: proto3.getEnumType(CountryCodes) },
    { no: 2, name: "state_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: State} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Country {
    return new Country().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Country {
    return new Country().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Country {
    return new Country().fromJsonString(jsonString, options);
  }

  static equals(a: Country | PlainMessage<Country> | undefined, b: Country | PlainMessage<Country> | undefined): boolean {
    return proto3.util.equals(Country, a, b);
  }
}

